ðŸ«µIn nodejs every single file is treated as module
ðŸ«µModule is object that we have access to in each and every node js module

NPM packages follows semantic version notation three digit --> major version , minor version and patch version
so new version may affect the code if our code is written in old version.

so we can check packages which are deprecated by command  -------------> npm outdated 
this command will display table of outdated packages.
Package  Current Wanted Latest  Location
slugify   I.O.O  1.3.4   1.3.4


we can also download the specific version of any package using -------------> npm i slugify@1.0.0

âœ… Instead of ^ (minor and patch releases) this symbol we can use ~ symbol for strictly that patch version which is safe side * symbol bumps all the versions

âœ… We can update package by npm update slugify 
âœ… We can delete any package by npm uninstall slugify
âœ… Package.lock.json file contains info about dependancies of dependancies along with versions
âœ… Whenever we share our code must provide Package.lock.json and Package.json file
______________________________________________________________________________________________________________________________________

âœ… Event loop does the orchestration means it receives events , calls there call back functions, and offloads there more expensive tasks to the thread pool, event loop that makes asynchronous programming possible in node

1.nexttick()
2.setImmediate()   -> it depends on polling phase 
3.setTimeout()

/We can change the size of thread pool from 4 to requied
process.env.UV_THREADPOOL_SIZE = 1 ; //we have decreased it from 4 to 1
______________________________________________________________________________________________________________________________________

Nodes event driven architecture

Event emmiter ---------------------> Event listner -------> callBacks
		emits event 			     calls 
______________________________________________________________________________________________________________________________________

Streams :
âœ… When we read files using Streams , we read part of the data do something with it and free our memory , we repeat this
until the entire file processing e.g. youtube and netflix follows the same principle --> Instead of loading full videos 
process by piece by piece

âœ… Steams are useful for handling large volumes of data

âœ… More efficient in terms of  memory 
âœ… Streams are instances of EventEmmiter class

______________________________________________________________________________________________________________________________________'

âœ… require functions is called with a module name as the argument the path to the modules file has been resolved into
  file loaded all the code has been wrapped into wrapper function which has then executed after execution it will 
  return exports of required module then after first time loading they are cached 

______________________________________________________________________________________________________________________________________
Callback hell is just a problem with nested callbacks we can resolve these problem using 
promises so promises are just like packages which are filled in future means when we are getting 
data in future in beginning we have promise but it is pending promise once we get data in it
it becomes resolved promise .

âœ… resolved promise eighter can be fullfilled(it have our required data)or rejected(it have error)
âœ… .then(callback) it only deals with fullfilled promises for rejected we have to use catch method
