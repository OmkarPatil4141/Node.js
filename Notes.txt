ðŸ«µIn nodejs every single file is treated as module
ðŸ«µModule is object that we have access to in each and every node js module

NPM packages follows semantic version notation three digit --> major version , minor version and patch version
so new version may affect the code if our code is written in old version.

so we can check packages which are deprecated by command  -------------> npm outdated 
this command will display table of outdated packages.
Package  Current Wanted Latest  Location
slugify   I.O.O  1.3.4   1.3.4


we can also download the specific version of any package using -------------> npm i slugify@1.0.0

âœ… Instead of ^ (minor and patch releases) this symbol we can use ~ symbol for strictly that patch version which is safe side * symbol bumps all the versions

âœ… We can update package by npm update slugify 
âœ… We can delete any package by npm uninstall slugify
âœ… Package.lock.json file contains info about dependancies of dependancies along with versions
âœ… Whenever we share our code must provide Package.lock.json and Package.json file
______________________________________________________________________________________________________________________________________

âœ… Event loop does the orchestration means it receives events , calls there call back functions, and offloads there more expensive tasks to the thread pool, event loop that makes asynchronous programming possible in node

1.nexttick()
2.setImmediate()   -> it depends on polling phase 
3.setTimeout()

/We can change the size of thread pool from 4 to requied
process.env.UV_THREADPOOL_SIZE = 1 ; //we have decreased it from 4 to 1
______________________________________________________________________________________________________________________________________

Nodes event driven architecture

Event emmiter ---------------------> Event listner -------> callBacks
		emits event 			     calls 
______________________________________________________________________________________________________________________________________

Streams :
âœ… When we read files using Streams , we read part of the data do something with it and free our memory , we repeat this
until the entire file processing e.g. youtube and netflix follows the same principle --> Instead of loading full videos 
process by piece by piece

âœ… Steams are useful for handling large volumes of data

âœ… More efficient in terms of  memory 
âœ… Streams are instances of EventEmmiter class

______________________________________________________________________________________________________________________________________'

âœ… require functions is called with a module name as the argument the path to the modules file has been resolved into
  file loaded all the code has been wrapped into wrapper function which has then executed after execution it will 
  return exports of required module then after first time loading they are cached 

______________________________________________________________________________________________________________________________________
Callback hell is just a problem with nested callbacks we can resolve these problem using 
promises so promises are just like packages which are filled in future means when we are getting 
data in future in beginning we have promise but it is pending promise once we get data in it
it becomes resolved promise .

âœ… resolved promise eighter can be fullfilled(it have our required data)or rejected(it have error)
âœ… .then(callback) it only deals with fullfilled promises for rejected we have to use catch method
______________________________________________________________________________________________________________________________________
âœ… Building promises
   1. we will return new Promise(resolve,reject) reject have error and resolve(data) this data is then available
   in then(data=>{}) means resolve getting data passes to then
   2. if(err) reject("error") whatever in reject then it available to catch(err)
______________________________________________________________________________________________________________________________________
âœ… Instead of consuming promises with then method , we can use async await 
âœ… async await is also known syntactic sugar for promises
âœ… await always used inside the as function
âœ… Async function returns promises , in order to display we use then method and for error we use catch method but in trys catch we have 
	to throw error
âœ… Async functions runs in background while other code is in event loop 
______________________________________________________________________________________________________________________________________
âœ…Express do not put body dat on to request, hence we have to use middleware
âœ…Middleware is just a function that can modify the incoming request data , its called middleware because it stands 
  between middle in req and res.
âœ… Object.assign({},{}) which allows us to create a new object by merging two existing objects
âœ… app.get('/api/vl/tours/:id, (req, res) => {
     console. log ( req. params),}) 
âœ…Params ->object that  all the parameters of all the variables we defined there are stored (:id in above code )

âœ… We can add also optional parameters /:id? now id becomes option means whenever we hitting url we can or cannot specify id
âœ… In javascript if we have one string which is numberer e.g "45" that when multiply with 1 e.g. "45"*1 => 45

âœ… For updating we have 2 methods put and patch
   put -> we expect that our application recieves entire new upsated object 
   patch -> we only expect th properties that actually be updated on object
______________________________________________________________________________________________________________________________________


âœ… We can refactor our routes -> app.route().get(------)
âœ… middleware -> request rsponse cycle , starts with incoming request then executing all the middleware
    in the middleware stack step by step (.next()) and finally sending the response to finish the cycle 

âœ…   Order lots matter in âœ…Express becuse when we put our custom middleware below route it ends req-res cycle
      means when we keep custom middleware in between gettours and by id 

âœ… e.g we require Date at one of the route then we use middleware to fetch the date from req and then use it in route 

______________________________________________________________________________________________________________________________________
Third party middleware function called morgan
âœ… It allows us to see request data right in console 

âœ… mounting => in order to use it in different files

const tourRoute = express.Router(); // one separate route for each resource
const UserRoute = express.Router();
app.use('/api/v1/tours',tourRoute)
app.use('/api/v1/users',tourRoute)

âœ… When we use exports. and them we require it in another file we get all that multiple exports in one object
    {so we can destructure it by same names } or we can use that object.name

 âœ…WE can keep only middlewares in our app.js 
 1->take routes from app.js make them middleware using mounting
 2-> put them in routes folder (run and check whether everything is working properly)
 3->  take all route handlers and make another folder as controller
 4->  paste and export them
 5-> require them in routes
 6-> create server .js in which put all the server/db related things 
 7-> export our app from app.js (because we keep all the things related to expreess in app)
 âœ… Param middleware is the middleware that only runs with certain parameters
    in Param middleware function we actually get access to a fourth argument which is the 
    value of parameter in question

______________________________________________________________________________________________________________________________________
âœ… These is known as chaining middlewares ->
    router.route('/').get(tourController.getTours).post(tourController.createTour)
    if we want to add middleware for any perticular method e.g. post(), then 
    just add as a first parameter e.g. post(middlewarefunction ,tourController.createTour)

âœ… we can serve static files from a folder from not a route then we have to use inbult middleware as

   app.use(express.static('dir_name'))  for each part of website there is different request

âœ… environment variables : NODE ENV=development nodemon server. js
   instead of keeping all environment in command we can keep them in one file
   1. create file
   2. put variables in it
   3. npm i dotenv
   4. require dotenv and 


âœ… npm i eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-config-airbnb eslint-plugin-node eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react --save-dev